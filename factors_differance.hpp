


//->=decltype(in_tolog)??

#pragma once

#include <vector>
#include <valarray>

const  int PROB_TABLE_SIZE = 5;

typedef std::valarray<double> two_term_val_ary={0,0};
class factor_s_probability_differance
{


  private :

  std::vector<two_term_val_ary*> sample_self_2trm;
  std::vector<two_term_val_ary*> to_comarpass_list_2rm;


  public :
  std::valarray<double> samp_totals(const std::valarray<double> &in_val_ar)
  {
    //return sample_self+in_val_ar;
  }

struct prevz_incounterz
{
  double last_losses;
  double last_inflicted;
  double gain;

  double total_losses;
  double total_inflicted;
  double total_gains;


   std::valarray<double> outc_pbz[PROB_TABLE_SIZE];

};


std::valarray<double>* trazmit_current_table()
{

}
template <class entiy_type>
void inputprocg(entiy_type self,entiy_type refrnt)
{
if(does)
{
  return cmd_msg.. call



}

}

 bool Handle_telagram(const telagram& tela)
{
  //covekvisome goof blood.z.. 
  //needs to call the copoents, wrope them in, to a delayed call. so the thread colid.
}

  template<class inentity>
  run_exchange_probabilities()
    {
      std::valarray<double> working_val={0,0,0,0};

      for (size_t i= 0; i< to_comarpass_list.size();i++)
        {

            two_term_val_ary*  temp_inref_val_ary  = to_comarpass_list.at(i);
            two_term_val_ary*  temp_self_val_ary  = sample_self_2trm.at(i);

            //sample_self_2trm.at(i)+o_comarpass_list.at(i);
            output_val[0]
             = *temp_inref_val_ary+ *temp_self_val_ary;
            std::valarray<double> difrenz = *temp_inref_val_ary- *temp_self_val_ary;

            double prb_A = *temp_self_val_ary/sum;
            double prob_B = *temp_inref_val_ary/sum;





            //*temp_inref_val_ary;

        }



    }



};
